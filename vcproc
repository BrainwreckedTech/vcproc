#!/bin/bash

# © 2016-2017 Paul A. Hinchberger III aka BrainwreckedTech.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

ET_BGN=$(cut -d\  -f1 < /proc/uptime)

MISSDP=false

! command -v dialog &> /dev/null && echo "Could not find dialog" && MISSDP=true
! command -v ffmpeg &> /dev/null && echo "Could not find ffmpeg" && MISSDP=true
! command -v awk &> /dev/null && echo "Could not find awk" && MISSDP=true
! command -v mediainfo &> /dev/null && echo "Could not find mediainfo" && MISSDP=true

${MISSDP} && exit 1

CLBOLD="$(tput bold)"
CLNORM="$(tput sgr0)"
CLBGRN="$(echo -e "\e[1;92m")"
FFOPTS="-y -v info -stats"
FFOPTS="-y -v fatal -stats"  # For debugging, comment this to keep -v info
SCRPNM="$(basename "${0}")"
TMPDIR="/tmp/vcproc-${USER}"
CRPTOP=0
CRPLFT=0
CRPBTM=0
CRPRIT=0
MPVBIN=true
CRF=22

function pak {
  read -r -n1 -r -s -p 'Press any key to continue...'
}

function elapsed_time {
  sec2tc $( awk "BEGIN { print $(cut -d\  -f1 < /proc/uptime) - ${ET_BGN} }" )
}

function msg() {
  echo "${CLBOLD}${2}[$(elapsed_time)] ${1}${CLNORM}"
}

function tc2sec() {
  printf "%01.3f" "$((10#${1:0:2} * 3600 + 10#${1:3:2} * 60 + 10#${1:6:2})).${1:9:3}"
}

function sec2tc() {
  WHLS=$(printf "%01d" "${1%\.*}")
  MILS="$(( 10#${1#*\.} + 0 ))"

  ((HOUR=${WHLS}/3600))
  ((MINS=(${WHLS}%3600)/60))
  ((SECS=${WHLS}%60))
  printf "%02d:%02d:%02d.%03d" ${HOUR} ${MINS} ${SECS} ${MILS:0:3}
}

function istc() {
  [[ ${1} =~ ^[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}$ ]] && return 0 || return 1
}

function get_file_dialog() {
  RESULT=""
  while [ ! -s "${RESULT}" -o "${RESULT}" == "" ]; do
    RESULT="$(${DLGBIN} --stdout --title ' Select video file to work on: ' --fselect "${1}" 10 72)"
  done
  echo "${RESULT}"
}

function list_video_files {
  echo "$(find -maxdepth 1 -regextype posix-extended -regex '\.\/[[:print:]]+\.(3gp|3g2|asf|avi|divx|evo|f4v|flv|m2p|mkv|mka|mks|mcf|mp4|mov|mpeg|mpg|mxf|ogg|ps|ts|qt|rmvb|vob|webm|wma|wmv)' | sed 's:^\./::g')"
}

function load_config {

  CFGFLS=()
  WALKED=

  [ -s "${HOME}/.config/vcproc/${SCRPNM}.cfg" ] && CFGFLS+=("${HOME}/.config/vcproc/${SCRPNM}.cfg")

  while true; do
    [ "${WALKED}" == "${PWD}" ] && break
    TOWALK="${PWD#${WALKED}/}"
    WALKIN="${WALKED}/${TOWALK%%/*}"
    [ -s "${WALKIN}/${SCRPNM}.cfg" ] && CFGFLS+=("${WALKIN}/${SCRPNM}.cfg")
    WALKED="${WALKIN}"
  done

  for VCPCFG in "${CFGFLS[@]}"; do

    tr '\r' '\n' < "${VCPCFG}" > ${TMPDIR}/${SCRPNM}.unix
    sed -i '/^$/d' ${TMPDIR}/${SCRPNM}.unix
    touch -d "$(date -R -r "${VCPCFG}")" "${TMPDIR}/${SCRPNM}.unix"
    mv ${TMPDIR}/${SCRPNM}.unix "${VCPCFG}"

    while IFS='= ' read -r lhs rhs; do
      if [[ ! $lhs =~ ^\ *# && -n $lhs ]]; then
        rhs="${rhs%%\#*}"             # Del in line right comments
        rhs="${rhs%"${rhs##*[^ ]}"}"  # Del trailing spaces
        rhs="${rhs%\"*}"              # Del opening string quotes
        rhs="${rhs#\"*}"              # Del closing string quotes
        SETSTR+="$lhs='$rhs';"
      fi
    done < "${VCPCFG}"
  done

  echo "${SETSTR}"
}

function check_config {

  ALLSET=true

  if [ ! -s "${SCRPNM}.cfg" ]; then
    msg "File ${SCRPNM}.cfg not found." && ALLSET=false
  else
    [ -z ${VDOFIL+X} ] && msg 'ERROR: VDOFIL is not set' && ALLSET=false
    [ -z ${VIP_TC+X} ] && msg 'ERROR: VIP_TC is not set' && ALLSET=false
    [ -z ${VOP_TC+X} ] && msg 'ERROR: VOP_TC is not set' && ALLSET=flase
    [ -z ${OPWIDE+X} ] && msg 'ERROR: OPWIDE is not set' && ALLSET=flase
    [ -z ${OPHIGH+X} ] && msg 'ERROR: OPHIGH is not set' && ALLSET=flase
    [ -z ${IPCRNG+X} ] && msg 'ERROR: IPCRNG is not set' && ALLSET=flase
    [ -z ${OPCRNG+X} ] && msg 'ERROR: OPCRNG is not set' && ALLSET=flase
    [ -z ${FRMRAT+X} ] && msg 'ERROR: FRMRAT is not set' && ALLSET=flase
    [ -z ${VDODAR+X} ] && msg 'ERROR: VDODAR is not set' && ALLSET=flase
  fi

  if ${ALLSET}; then
    CFPASS=true
    [ ! -s "${VDOFIL}" ] && msg "ERROR: VDOFIL ${VDOFIL} not found." && CFPASS=false
    [ "${OPWIDE}" -ne "${OPWIDE}" ] && msg 'ERROR: OPWIDE is not an integer' && CFPASS=false
    [ "${OPHIGH}" -ne "${OPHIGH}" ] && msg 'ERROR: OPHIGH is not an integer' && CFPASS=false
    istc "${VIP_TC}" || { msg "ERROR: VIP_TC is not a time code."; CFPASS=false; }
    istc "${VOP_TC}" || { msg "ERROR: VOP_TC is not a time code."; CFPASS=false; }
  else
    CFPASS=false
  fi

  if ${CFPASS}; then
    [ $((${OPWIDE} % 8)) -ne 0 -o $((${OPHIGH} % 8)) -ne 0 ] && \
      msg "WARNING: ${OPWIDE}x${OPHIGH} is not standard (dimensions not divisible by 8)."
    [ "${OPWIDE}x${OPHIGH}" == "854x480" ] &&
      msg "WARNING: 854x480 is a defacto standard."
  fi

  return $(( ${CFPASS} ))

}

function nnd_compat_check {
  SARDEC=$( awk "BEGIN { print int( ${OPWIDE} / ${OPHIGH} * 1000 + 0.5 ) / 1000 }" )
  DARDEC=$( awk "BEGIN { print int( ${VDODAR} * 1000 + 0.5 ) / 1000 }" )
  if [  ${SARDEC} != ${DARDEC} ]; then
    OPWIDE=$(( ( ${OPHIGH} * ${VDODAR%/*} + ${VDODAR#*/} ) / ${VDODAR#*/} ))
    echo "OPWIDE='${OPWIDE}';OPHIGH='${OPHIGH}';"
  fi
}

function process_config {

  VIPSEC="$(tc2sec "${VIP_TC}")"
  VOPSEC="$(tc2sec "${VOP_TC}")"

  if [ -n "${OPWIDE}" ] && [ -n "${OPHIGH}" ] && \
     [ -n "${IPCRNG}" ] && [ -n "${OPCRNG}" ] && [ -n "${FRMRAT}" ]; then
    GOPLEN="-g $( awk "BEGIN { print int( ( ${FRMRAT} + 1 ) / 2 ) }" )"
    if [ ${CRPTOP} == 0 -a ${CRPLFT} == 0 -a ${CRPBTM} == 0 -a ${CRPRIT} == 0 ]; then
      CRPFLT=
    else
      OVWIDE=$(mediainfo "${VDOFIL}" | grep Width | sed 's/\([[:digit:]]\) \([[:digit:]]\)/\1\2/g;s/.*: \([[:digit:]]\+\) pixels/\1/g')
      OVHIGH=$(mediainfo "${VDOFIL}" | grep Height | sed 's/\([[:digit:]]\) \([[:digit:]]\)/\1\2/g;s/.*: \([[:digit:]]\+\) pixels/\1/g')
      CRWIDE=$(( ${OVWIDE} - ${CRPLFT} - ${CRPRIT} - 1))
      CRHIGH=$(( ${OVHIGH} - ${CRPTOP} - ${CRPBTM} - 1))
      CRPFLT="crop=${CRWIDE}:${CRHIGH}:$((${CRPLFT}+1)):$((${CRPTOP}+1)),"
    fi
    V_FLTR="${CRPFLT}scale=width=${OPWIDE}:height=${OPHIGH}:in_range=${IPCRNG}:out_range=${OPCRNG},fps=fps=${FRMRAT},setdar=dar=${VDODAR/\//:}"
  fi

  [ -n "${VIPSEC}" ] && [ -n "${VOPSEC}" ] && DURATN=$( awk "BEGIN { print ${VOPSEC} - ${VIPSEC} }" )
  [ -n "${ADPEAK}" ] && [ -n "${MTLEAD}" ] && A_FLTR="volume=${ADPEAK}dB,volume=enable=between'(t,0,$( awk "BEGIN { print ${MTLEAD} + ${VIPSEC} }" ))':volume=0"

  OPSET1="-preset slower -refs 4"
  YTVSET="-bf 2 ${GOPLEN} -flags +cgop -movflags faststart"
  OPSET2="-pix_fmt yuv420p -profile:v high -level 4.2"
  YTASET="-strict 2 -b:a 384k -r:a 48000"

}

function enable_usetmp {

  touch ${PROCES}.mp4

  if [ -z ${USETMP+X} ]; then
    WRKFIL="${VDOFIL}"
    OUTFIL="${PROCES}.mp4"
  else
    WRKFIL="${TMPDIR}/${VDOFIL}"
    OUTFIL="${TMPDIR}/${PROCES}.mp4"
    msg "Copying ${VDOFIL} to ${WRKFIL}..."
    cp "${VDOFIL}" "${WRKFIL}"
  fi

  echo "WRKFIL='${WRKFIL}';OUTFIL='${OUTFIL}'"

}

function get_pts_start {
  STRTTM=$(ffprobe -v fatal -select_streams v -show_streams -show_entries stream=start_time -of csv "${1}" | grep program | cut -d, -f3 | tr -d '\n')
  [ "${STRTTM}" == "" ] && STRTTM=0
  echo ${STRTTM}
}

function get_closest_iframe {
  OVFILE="${1}"
  IPOINT="${2}"
  OPOINT="${3}"
  IDRCTN="${4}"
  SLCKTM="${5}"

  for IFDRTN in 5 20 35; do
    [[ $( awk "BEGIN { print (${IPOINT} < ${IFDRTN}) }" ) == 1 ]] && RISTRT=0 || RISTRT="$( awk "BEGIN { print ${IPOINT} - ${IFDRTN} }" )"
    RISTOP="$( awk "BEGIN { print ${IPOINT} + ${IFDRTN} }" )"
    [[ $( awk "BEGIN { print (${RISTOP} > ${OPOINT}) }" ) == 1 ]] && RISTOP="${OPOINT}"
    RIDRTN="$( awk "BEGIN { print ${RISTOP} - ${RISTRT} }" )"

    ffprobe -v fatal -select_streams v -show_frames -show_entries frame=pict_type,pkt_pts_time -read_intervals "0${RISTRT}%+0${RIDRTN}" -of csv "${OVFILE}" | grep I | cut -d, -f2 > ${TMPDIR}/iframes.times

    [ -s "${TMPDIR}/iframes.times" ] && break
  done

  while read -r FRAME; do
    awk "BEGIN { print ${FRAME} - ${STRTTM} }" | xargs printf '%01.3f\n'
  done < ${TMPDIR}/iframes.times > ${TMPDIR}/iframes.list
  rm ${TMPDIR}/iframes.times

  #msg "Getting closest I-frame ${VDOBGN} in-point..."
  cp ${TMPDIR}/iframes.list ${TMPDIR}/iframes.copy
  awk "BEGIN { print ${IPOINT} - ${SLCKTM} }" >> ${TMPDIR}/iframes.copy
  sort -n ${TMPDIR}/iframes.copy > ${TMPDIR}/iframes.sort
  rm ${TMPDIR}/iframes.copy
  [[ "${IDRCTN}" == "after" ]] && TIPSEC=$(grep -A 1 "$( awk "BEGIN { print ${IPOINT} - ${SLCKTM} }" )" ${TMPDIR}/iframes.sort | tail -1 | tr -d '\n')
  [[ "${IDRCTN}" == "before" ]] && TIPSEC=$(grep -B 1 "$( awk "BEGIN { print ${IPOINT} - ${SLCKTM} }" )" ${TMPDIR}/iframes.sort | head -1 | tr -d '\n')
  rm ${TMPDIR}/iframes.sort

  TOPSEC=$( awk "BEGIN { print ${OPOINT} + ${SLCKTM} }" )
  TRMDUR=$( awk "BEGIN { print ${TOPSEC} - ${TIPSEC} }" )

  echo "TIPSEC='${TIPSEC}';TOPSEC='${TOPSEC}';TRMDUR='${TRMDUR}';"
}

function get_video_duration {
  VDDRTN=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${1}")
  echo $( awk "BEGIN { print int( ${VDDRTN} * 1000 + 0.5 ) / 1000 }" )
}

function set_crf {
  # We expect $1 to be crf=nn or max=nn
  IFS='=' read VAR VAL <<< "${1}"

  case "${VAR}" in 
    crf)
      echo "${VAL}"
      ;;
    max)
      [ "${VAL}" -lt 26 ] && echo '22'                    #            DXID FTIP FTSR
      [ 26 -lt "${VAL}" -a "${VAL}" -lt 28 ] && echo '21' # Actual max 25.3 23.0 22.3
      [ 29 -lt "${VAL}" -a "${VAL}" -lt 31 ] && echo '20' # Actual max 28.2 26.9 26.2
      [ 32 -lt "${VAL}" -a "${VAL}" -lt 35 ] && echo '19' # Actual max 31.5 31.2 30.6
      [ 36 -lt "${VAL}" -a "${VAL}" -lt 40 ] && echo '18' # Actual max 35.2 35.9 35.4
      [ 41 -lt "${VAL}" -a "${VAL}" -lt 46 ] && echo '17' # Actual max 39.1 41.0 40.7
      [ 47 -lt "${VAL}" -a "${VAL}" -lt 52 ] && echo '16' # Actual max 43.4 46.4 46.3
      [ 53 -lt "${VAL}" -a "${VAL}" -lt 58 ] && echo '15' # Actual max 48.0 52.0 52.2
      [ 59 -lt "${VAL}" -a "${VAL}" -lt 64 ] && echo '14' # Actual max 52.9 57.8 58.3
      [ 65 -lt "${VAL}" -a "${VAL}" -lt 71 ] && echo '13' # Actual max 58.2 63.8 64.7
      [ 72 -lt "${VAL}" -a "${VAL}" -lt 78 ] && echo '12' # Actual max 64.0 70.2 71.5
      [ 79 -lt "${VAL}" -a "${VAL}" -lt 86 ] && echo '11' # Actual max 70.4 77.2 78.7
      [ "${VAL}" -gt 86 ] && echo '10'                    # Actual max 77.5 84.6 86.6
      ;;
    *)
      echo '22'
      ;;
  esac
}

! command -v mpv &> /dev/null && \
msg "Could not find mpv.  Play videos for `set` and `trim` manually." && MPVBIN=false

grep -q 'PRETTY_NAME="Ubuntu ..\...\.. LTS"' /etc/os-release && \
grep -q 'Linux version .*-Microsoft (Microsoft@Microsoft.com)' /proc/version && \
ON_WSL=true || ON_WSL=false

[ -z ${DISPLAY+x} ] && DLGBIN=dialog || DLGBIN=Xdialog
DLGBIN=dialog

mkdir -p "${TMPDIR}"

[[ "|normalize|preview|vcap|youtube|portable|lossless|join|" == *"|${1}|"* ]] && [[ ! -s ${1}.mp4 ]] && touch ${1}.mp4

PROCES="${1}"

case ${PROCES} in

  remux)

    if [ -n "${2}" ] && [ -s "${2}" ]; then
      VDOFIL="${2}"
    elif [ -z ${VDOFIL+x} ]; then
      VDOFIL="$(list_video_files)"
      if [ "$(echo -n "${VDOFIL}" | wc -l)" -eq "0" ]; then
        [ -n "${VDOFIL}" ] && msg "Found file ${VDOFIL}" || VDOFIL="$(get_file_dialog)"
      else
        VDOFIL="$(get_file_dialog)"
      fi    fi

    VDOEXT="${VDOFIL##*.}"

    msg "Remuxing ${VDOFIL}..."
    ffmpeg ${FFOPTS} -i "${VDOFIL}" -c:v copy -c:a copy -avoid_negative_ts make_zero "tmp.${VDOEXT}"
    mv "tmp.${VDOEXT}" "remux.${VDOEXT}"

    ;;

  trim)

    [[ -z ${SLACKTIME+X} ]] && SLACKR=3 || SLACKR=${SLACKTIME} # Number of extra seconds to keep when trimming

    shift
    ! [[ -s "${1}" ]] && echo "${1} does not exist." && exit 1
    VDOFIL="${1}"

    TCCNCL=false
    VIPSEC=()
    VOPSEC=()

    if [ -s trim.cfg ]; then
      ${DLGBIN} --yesno "\n Load $(wc -l < trim.cfg) trims from save file?" 7 37
      if [ ${?} -eq 0 ]; then
        while read -r TM_CDS; do
          VIPSEC+=("$(tc2sec "${TM_CDS%-*}")")
          VOPSEC+=("$(tc2sec "${TM_CDS#*-}")")
        done < trim.cfg
      fi
    fi

    TM_CDS=

    ${MPVBIN} && mpv --osd-fractions --osd-level=2 --loop=inf --pause "${VDOFIL}" &>/dev/null &

    while true; do
      HLPMSG="Video #$(( ${#VIPSEC[@]} + 1 ))\n\nYou can do multiple trims in one go.\n\nEnter time codes in HH:MM:SS.sss format.\n\nPress Cancel when you are finished."
      TIMCDS="$(${DLGBIN} --stdout --title 'In/Out Points' --form "${HLPMSG}" 15 45 0 " In Point:" 1 1 "${TM_CDS%-*}" 1 12 13 0 "Out Point:" 2 1 "${TM_CDS#*-}" 2 12 13 0)"
      if [ ${?} -eq 0 ]; then
        TCTRIM="${TIMCDS%-}"
        TM_CDS="${TCTRIM//$'\n'/-}"
        if istc "${TM_CDS%-*}" && istc "${TM_CDS#*-}"; then
          echo "${TM_CDS}" >> trim.cfg
          VIPSEC+=("$(tc2sec "${TM_CDS%-*}")")
          VOPSEC+=("$(tc2sec "${TM_CDS#*-}")")
          TM_CDS=
        else
          ${DLGBIN} --title 'OOPS!' --msgbox "${TIMCDS} are invalid time codes.  Try again." 0 0
        fi
      elif [ ${?} -eq 1 ]; then
        break
      fi
    done

    for VDOFIL in "$@"; do

      VDOEXT="${VDOFIL##*.}"

      STRTTM=$(get_pts_start "${VDOFIL}")
      msg "Presentation Time Stamps start at $(sec2tc ${STRTTM}) for ${VDOFIL}..."

      for (( LPCNTR=0; LPCNTR<${#VIPSEC[@]}; LPCNTR++ )); do

        OFFSET=0

        msg "WORKING ON ${VDOFIL^^} TRIM $(( ${LPCNTR} + 1 )) OF ${#VIPSEC[@]}, TRIM FROM $(sec2tc ${VIPSEC[${LPCNTR}]}) TO $(sec2tc ${VOPSEC[${LPCNTR}]})"

        msg "Finding closest iframe before In-Point..."
        eval "$(get_closest_iframe ${VDOFIL} ${VIPSEC[${LPCNTR}]} ${VOPSEC[${LPCNTR}]} before ${SLACKR})"

        msg "Trimming ${VDOFIL} for duration of $(sec2tc ${TRMDUR}) ($(sec2tc ${TIPSEC})-$(sec2tc ${TOPSEC}))"
        ffmpeg ${FFOPTS} -ss "${TIPSEC}" -i "${VDOFIL}" -to "${TRMDUR}" -c:v copy -c:a copy -avoid_negative_ts make_zero "tmp.${VDOEXT}"

        while true; do
          if [ -e ${VDOFIL%.*}_trim_$(printf "%03d" "$((${LPCNTR}+${OFFSET}+1))").${VDOEXT} ]; then
            ((OFFSET+=1))
          else
            break
          fi
        done

        mv "tmp.${VDOEXT}" "${VDOFIL%.*}_trim_$(printf "%03d" "$((${LPCNTR}+${OFFSET}+1))").${VDOEXT}"

      done
    done

    [[ $(( ${#VIPSEC[@]} + ${OFFSET} )) == 1 ]] && rename '_trim_001' '_trim' *_trim_???.*

    ;;

  set)

   eval "$(load_config)"

   function ask_copy_cfg() {

      SETING="$(grep -q "${1}=" ${SCRPNM}.cfg 2> /dev/null)"
      [[ "${SETING}" == "" ]] && return 1
      echo "Found: ${SETING}"
      read -p "Do you want to copy this setting from existing ${SCRPNM}.cfg? [y/N] " RESULT
      if [ "${RESULT,,}" == "y" ]; then
        eval "$(printf '%q' "${SETING}")"
        echo "${SETING}" >> ${TMPDIR}/${SCRPNM}.tmp
      else
        return  1
      fi
    }

    if [ -n "${2}" ] && [ -s "${2}" ]; then
      VDOFIL="${2}"
    elif [ -z ${VDOFIL+x} ]; then
      VDOFIL="$(list_video_files)"
      if [ "$(echo -n "${VDOFIL}" | wc -l)" -eq "0" ]; then
        [ -n "${VDOFIL}" ] && msg "Found file ${VDOFIL}" || VDOFIL="$(get_file_dialog "$(realpath ${VDOFIL})")"
      else
        VDOFIL="$(get_file_dialog)"
      fi
    fi

    VDOEXT="${VDOFIL##*.}"
    echo "VDOFIL=${VDOFIL#$(pwd)/}" > ${TMPDIR}/${SCRPNM}.tmp

    if [ -z ${OPWIDE+X} ] && [ -z ${OPHIGH+X} ] && [ -z ${FRMRAT+X} ] && [ -z ${VDODAR+X} ]; then
      HLPMSG='These properties were auto-detected.  Please verify them.'
      eval $(mediainfo "${VDOFIL}" | grep 'Width\|Height\|Display aspect ratio\|Frame rate' | grep -v 'mode\|spf' | sed 's/ *: /=/g;s/Display aspect ratio/VDODAR/g;s/Frame rate/FRMRAT/g;s/Height/OPHIGH/g;s/Width/OPWIDE/g;s/ pixels//g;s/ FPS//gI;s/ //g;s/(.*)//g;s/\.0\+//g;s|:|/|g')
    else
      HLPMSG='These properties were pulled from existing config.  Please verify them.'
    fi

    SPROPS="$(${DLGBIN} --stdout --title 'Source Video Properties' --form "${HLPMSG}" 12 36 0 ' Width:' 1 1 "${OPWIDE}" 1 9 5 0 'Height:' 2 1 "${OPHIGH}" 2 9 5 0 '   FPS:' 3 1 "${FRMRAT}" 3 9 7 0 '   DAR:' 4 1 "${VDODAR}" 4 9 5 0 | tr '\n' '-' | sed 's/-$//g' )"

    SPROP1=${SPROPS%-*-*}; SPROP2=${SPROPS#*-*-}
    OPWIDE=${SPROP1%-*};   OPHIGH=${SPROP1#*-}
    FRMRAT=${SPROP2%-*};   VDODAR=${SPROP2#*-}

    echo -e "OPWIDE=${OPWIDE}\nOPHIGH=${OPHIGH}\nFRMRAT=${FRMRAT}\nVDODAR=${VDODAR}" >> ${TMPDIR}/${SCRPNM}.tmp

    HLPMSG="Video will be expanded to the dimensions you specified earlier.\n\nLeaving the settings at all zeros leaves cropping disabled."

    CRSETS="$(${DLGBIN} --stdout --title 'Crop Settings' --form "${HLPMSG}" 16 36 0 '   Crop Top:' 1 1 "${CRPTOP}" 1 14 5 0 '  Crop Left:' 2 1 "${CRPLFT}" 2 14 5 0 'Crop Bottom:' 3 1 "${CRPBTM}" 3 14 5 0 ' Crop Right:' 4 1 "${CRPRIT}" 4 14 5 0 | tr '\n' '-' | sed 's/-$//g' )"

    CRSET1=${CRSETS%-*-*}; CRSET2=${CRSETS#*-*-}
    CRPTOP=${CRSET1%-*};   CRPLFT=${CRSET1#*-}
    CRPBTM=${CRSET2%-*};   CRPRIT=${CRSET2#*-}

    echo -e "CRPTOP=${CRPTOP}\nCRPLFT=${CRPLFT}\nCRPBTM=${CRPBTM}\nCRPRIT=${CRPRIT}" >> ${TMPDIR}/${SCRPNM}.tmp

    if [ -z ${VIP_TC+X} ] && [ -z ${VOP_TC+X} ]; then
      HLPMSG="Enter time codes in HH:MM:SS.mmm format."
    else
      HLPMSG="These values were pulled from an existing config.  Please verify them.  Enter time codes in HH:MM:SS.mmm format."
      TM_CDS="${VIP_TC}-${VOP_TC}"
    fi

    ${MPVBIN} && mpv --osd-fractions --osd-level=2 --loop=inf --pause "${VDOFIL}" &>/dev/null &

    while true; do
      TM_CDS="$(${DLGBIN} --stdout --title 'In/Out Points' --form "${HLPMSG}" 12 36 0 " In Point:" 1 1 "${TM_CDS%-*}" 1 12 13 0 "Out Point:" 2 1 "${TM_CDS#*-}" 2 12 13 0 | tr '\n' '-' | sed 's/-$//g' )"
      istc "${TM_CDS%-*}" && istc "${TM_CDS#*-}" && break
      ${DLGBIN} --title 'OOPS!' --msgbox 'Invalid time code for in/out points.  Try again.' 0 0
    done

    VIP_TC=${TM_CDS%-*}; echo "VIP_TC=${VIP_TC}" >> ${TMPDIR}/${SCRPNM}.tmp
    VOP_TC=${TM_CDS#*-}; echo "VOP_TC=${VOP_TC}" >> ${TMPDIR}/${SCRPNM}.tmp

    if [ -z ${MTLEAD+X} ] && [ -z ${MTLAST+X} ]; then
      MTLEAD=0
      MTLAST=0
    fi

    HLPMSG='If you want to mute the audio at the beginning or end of the video, enter length of time here in seconds.'
    MUTSET="$(${DLGBIN} --stdout --title 'Mute Setting' --form "${HLPMSG}" 0 0 0 "Mute first seconds of audio:" 1 1 "${MTLEAD}" 1 30 5 0 " Mute last seconds of audio:" 2 1 "${MTLAST}" 2 30 5 0 | tr '\n' '-' | sed 's/-$//g' )"
    echo "MTLEAD=${MUTSET%-*}" >> ${TMPDIR}/${SCRPNM}.tmp
    echo "MTLAST=${MUTSET#*-}" >> ${TMPDIR}/${SCRPNM}.tmp

    if [ "${IPCRNG}" == pc ]; then
      TVSLCT=off; PCSLCT=on
    else
      TVSLCT=on; PCSLCT=off
    fi

    HLPMSG="What is the luma range in the source?\n\nOptical media typically uses Limited RGB.\n\nGame consoles output to Limited RGB unless you set them to use Full RGB.\n\nYou can take a snapshot from a video player and analyze the levels in an image editor if you are not sure."
    IPCRNG=$(${DLGBIN} --stdout --backtitle "Source Luma Scale" --radiolist "${HLPMSG}" 0 0 2 tv "Limited RGB (16-235)" ${TVSLCT} pc "Full RGB (0-255)" ${PCSLCT})
    echo "IPCRNG=${IPCRNG}" >> ${TMPDIR}/${SCRPNM}.tmp

    if [ "${OPCRNG}" == pc ]; then
      TVSLCT=off; PCSLCT=on
    else
      TVSLCT=on; PCSLCT=off
    fi

    HLPMSG="What is the luma range you would like in the output?\n\nLimited RGB will look slightly washed out on computer displays but fine on video displays.\n\nFull RGB will crush shadows and lights on video displays but look fine on computer displays."
    OPCRNG=$(${DLGBIN} --stdout --backtitle "Output Luma Scale" --radiolist "${HLPMSG}" 0 0 2 tv "Limited RGB (16-235)" ${TVSLCT} pc "Full RGB (0-255)" ${PCSLCT})
    echo "OPCRNG=${OPCRNG}" >> ${TMPDIR}/${SCRPNM}.tmp

    case "${PVWIDE}x${PVHIGH}" in
      '768x432') SELDAR=off; SEL169=on; SLCT43=off; break;;
      '640x480') SELDAR=off; SEL169=off; SLCT43=on; break;;
              *) SELDAR=on; SEL169=off; SLCT43=off; break;;
    esac

    HLPMSG="The preview video should be small (approx. 480p).\n\nCorrect way: Use the DVD standard 720x480 and set the DAR accordingly.\n\nCompatible way: Use 768x432 or 640x480 because some video players will not apply DAR correctly."
    OP_RES=$(${DLGBIN} --stdout --backtitle "Preview Size" --radiolist "${HLPMSG}" 0 0 3 '720x480' 'Use DAR (345600 pixels)' "${SELDAR}" '768x432' '1:1 for 16:9 (331776 pixels)' "${SEL169}" '640x480' '1:1 for 4:3 (307200 pixels)' "${SLCT43}")
    echo -e "PVWIDE=${OP_RES%x*}\nPVHIGH=${OP_RES#*x}" >> ${TMPDIR}/${SCRPNM}.tmp

    if ! ask_copy_cfg 'ADPEAK'; then
      ${DLGBIN} --infobox "\n Determining peak audio level..." 5 38
      ADPEAK="$(ffmpeg -i "${VDOFIL}" -ss "${VIP_TC}" -to "${VOP_TC}" -af "volumedetect" -f null /dev/null 2>&1 | grep max_volume | cut -d- -f2 | cut -d\  -f1)"
      echo "ADPEAK=${ADPEAK}" >> ${TMPDIR}/${SCRPNM}.tmp
      ${DLGBIN} --msgbox "\n Peak audio level of -${ADPEAK}dB added to config." 7 51
    fi

    sort -u ${TMPDIR}/${SCRPNM}.tmp > ./${SCRPNM}.cfg; rm ${TMPDIR}/${SCRPNM}.tmp

    ;;

  normalize)

    [ ! -s normalize.mkv ] && mv normalize.mp4 normalize.mkv || rm normalize.mp4

    VDOEXT="${2##*.}"

    MSSG01="Determining peak audio level..."
    MSSG02="Normalizing audio..."

    if [ "${INTERACTIVE}" = "0" ]; then
      msg "${MSSG01}"
    else
      ${DLGBIN} --infobox "\n ➞ ${MSSG01}\n   ${MSSG02}" 6 40
    fi

    ADPEAK="$(ffmpeg -i "${2}" -af "volumedetect" -f null /dev/null 2>&1 | grep max_volume | cut -d- -f2 | cut -d\  -f1)"
    A_FLTR="volume=${ADPEAK}dB,volume=enable=between'(t,0,0)':volume=0"

    if [ "${INTERACTIVE}" = "0" ]; then
      msg "${MSSG02}"
    else
      ${DLGBIN} --infobox "\n ✔ ${MSSG01}\n ➞ ${MSSG02}" 6 40
    fi

    ffmpeg ${FFOPTS} -i "${2}" -c:v copy -af ${A_FLTR} -c:a aac ${YTASET} normalize.mkv

    ;;

  preview)

    eval "$(load_config)"
    check_config
    process_config

    [ ! -s preview.mkv ] && mv preview.mp4 preview.mkv || rm preview.mp4

    case ${2} in
      ''|*[!0-9]*) msg 'Invalid or no custom duration specified.' ;;
      *) DURATN=${2} ;;
    esac

    T_FLTR=${V_FLTR/${OPWIDE}/${PVWIDE}}
    P_FLTR=${T_FLTR/${OPHIGH}/${PVHIGH}}

    msg "Creating preview video of length $(sec2tc "${DURATN}")..."
    ffmpeg ${FFOPTS} -i "${VDOFIL}" -ss "${VIP_TC}" -to "${VOP_TC}" -vf ${P_FLTR} -c:v libx264 -preset faster -crf 30 -af ${A_FLTR} -c:a libopus -b:a 48k preview.mkv

    ;;

  vcap)

    eval "$(load_config)"
    check_config
    process_config

    shift

    VDOEXT="mp4"
    VDOBGN="after"

    for OPTARG in "${@}"; do
      case "${OPTARG}" in
        mkv) shift ; VDOEXT=mkv ;;
        mp4) shift ; VDOEXT=mp4 ;;
        ifb) shift ; VDOBGN="before" ;;
        ifa) shift ; VDOBGN="after" ;;
      esac
    done

    [[ "${VDOEXT}" != "mp4" ]] && [[ ! -s vcap.mp4 ]] && mv vcap.mp4 vcap.${VDOEXT}

    STRTTM=$(get_pts_start "${VDOFIL}")
    msg "Presentation Time Stamps start at $(sec2tc ${STRTTM}) for ${VDOFIL}..."

    msg "Finding closest iframe ${VDOBGN} In-Point..."
    eval "$(get_closest_iframe ${VDOFIL} ${VIPSEC} ${VOPSEC} ${VDOBGN} 0)"

    msg "Creating ${VDOEXT^^} video from ${VDOFIL}, for $(sec2tc "${TRMDUR}") ($(sec2tc "${TIPSEC}") to $(sec2tc "${TOPSEC}"))"
    ffmpeg ${FFOPTS} -i "${VDOFIL}" -ss "${VIP_TC}" -to "${VOP_TC}" -c:v copy \
      -af ${A_FLTR} -c:a aac ${YTASET} -shortest vcap.${VDOEXT}

    ;;

  youtube)

    eval "$(load_config)"
    check_config
    CMPTRS="$(nnd_compat_check)"
    [ "${CMPTRS}" != "" ] && eval "${CMPTRS}" && msg "Changed video resolution to ${OPWIDE}x${OPHIGH} for NND"
    process_config
    eval "$(enable_usetmp)"

    shift

    for OPTARG in "${@}"; do
      case "${OPTARG}" in 
        crf=*|max=*) VCYTOA="${OPTARG//=/}"; CRF="$(set_crf "${OPTARG}")" ;;
      esac
    done

    msg "Using CRF ${CRF} to create video for $(sec2tc "${DURATN}") (${VIP_TC} to ${VOP_TC}) from ${VDOFIL}."
    ffmpeg ${FFOPTS} -i "${WRKFIL}" -ss "${VIP_TC}" -to "${VOP_TC}" \
      -vf ${V_FLTR} -c:v libx264 ${OPSET1} -crf ${CRF} ${YTVSET} ${OPSET2} \
      -af ${A_FLTR} -c:a aac ${YTASET} "${OUTFIL}"

    ;;

  portable)

    eval "$(load_config)"
    check_config
    process_config
    eval "$(enable_usetmp)"

    msg "Creating video from ${VDOFIL}, for $(sec2tc "${DURATN}") (${VIP_TC} to ${VOP_TC})"
    ffmpeg ${FFOPTS} -i "${WRKFIL}" -ss "${VIP_TC}" -to "${VOP_TC}" \
      -vf ${V_FLTR} -c:v libx264 ${OPSET1} -crf 29 ${OPSET2} \
      -af ${A_FLTR} -c:a aac ${YTASET} "${OUTFIL}"

    ;;

  lossless)

    eval "$(load_config)"
    check_config
    process_config

    [ ! -s lossless.mkv ] && mv lossless.mp4 lossless.mkv || rm lossless.mp4

    ffmpeg ${FFOPTS} -i "${VDOFIL}" -ss "${VIP_TC}" -to "${VOP_TC}" \
      -vf ${V_FLTR} -c:v ffv1 -level 3 -threads 6 -coder 1 -context 1 -g 1 -slices 6 -slicecrc 1 \
      -af ${A_FLTR} -c:a flac -compression_level 12 lossless.mkv

    ;;

  join)

    eval "$(load_config)"
    check_config
    CMPTRS="$(nnd_compat_check)"
    [ "${CMPTRS}" != "" ] && eval "${CMPTRS}" && msg "Changed video resolution to ${OPWIDE}x${OPHIGH} for NND"
    process_config

    JJOINS=
    JNDRTN=0
    JFILES=()
    JVFLTR=()
    JAFLTR=()
    shift

    while test $# -gt 0; do
      if [[ ${1} == max=?? || ${1} == crf=?? ]]; then
        CRF="$(set_crf "${1}")"
      elif [[ "|ifa|ifb|mkv|mp4|" == *"|${1}|"* ]]; then
        msg "Ignoring '${1}' (vcap) argument."
      else
        JJOINS+="[v${#JFILES[@]}][a${#JFILES[@]}]"
        if [ "${1}" == "vc" ]; then
          JVFLTR+=("trim=${VIPSEC}:${VOPSEC},${V_FLTR},setpts=PTS-STARTPTS[v${#JFILES[@]}];")
          JAFLTR+=("atrim=${VIPSEC}:${VOPSEC},${A_FLTR},asetpts=PTS-STARTPTS[a${#JFILES[@]}];")
          JFILES+=("-i ${VDOFIL}")
          JNDRTN=$( awk "BEGIN { print ${JNDRTN} + ${DURATN} }" )
        elif [ -s "${1}" ]; then
          JVFLTR+=("${V_FLTR},setpts=PTS-STARTPTS[v${#JFILES[@]}];")
          JAFLTR+=("asetpts=PTS-STARTPTS[a${#JFILES[@]}];")
          JFILES+=("-i ${1}")
          JNDRTN=$( awk "BEGIN { print ${JNDRTN} + $(get_video_duration "${1}") }" )
        else
          msg "File '${1}' does not exist or is 0 bytes." && exit 1
        fi
      fi
      shift
    done

    msg "Using CRF ${CRF} to join ${#JFILES[@]} videos for $(sec2tc ${JNDRTN}) estimated run time."
    for ((JOINLP=0; JOINLP<${#JFILES[@]}; JOINLP++)); do
      FILTER+="[${JOINLP}:v:0]${JVFLTR[${JOINLP}]} [${JOINLP}:a:0]${JAFLTR[${JOINLP}]} "
    done

    ffmpeg ${FFOPTS} ${JFILES[@]} \
      -filter_complex "${FILTER}${JJOINS}concat=n=${#JFILES[@]}:v=1:a=1 [v] [a]" \
      -map "[v]" -map "[a]" -c:v libx264 ${OPSET1} -crf ${CRF} ${YTVSET} ${OPSET2} \
      -c:a aac ${YTASET} temp.mp4
    [[ $? != 0 ]] && msg 'Error combining videos.' && exit 1
    mv temp.mp4 join.mp4

    ;;

  splitav)

    [ ! -s "${2}" ] && echo "${2} does not exist or is 0 bytes." && exit 1
    VDOEXT="${2##*.}"
    msg "Separating audio and video from ${2}..."
    ffmpeg ${FFOPTS} -i "${2}" -map 0:v:0 -c:v copy video.${VDOEXT} -map 0:a:0 -c:a copy audio.mp2
    [[ $? != 0 ]] && msg "Error separating video and audio from ${2}." && exit 1

    ;;

  csav)

    msg "Combining video from ${2} with audio from ${3}..."
    ffmpeg ${FFOPTS} -i "${2}" -i "${3}" -c copy -map 0:v:0 -map 1:a:0 -shortest yt.mp4
    [[ $? != 0 ]] && msg "Error combining video from ${2} with audio from ${3}." && exit 1

    ;;

  fixar)

    [ ! -s "${2}" ] && echo "${2} does not exist or is 0 bytes." && exit 1
    VDOEXT="${2##*.}"
    ffmpeg ${FFOPTS} -i "${2}" -aspect "${3}" -c copy fixar.${VDOEXT}
    mv fixar.${VDOEXT} ${2}
    ;;

  homearch)

    eval "$(load_config)"
    check_config
    process_config

    VDOSET="-c:v libx264 -preset slower -crf 5 -qmin 0 -qmax 10 -refs 12 -bf 16 -profile:v high -level 4.2"
    AUDSET="-c:a flac -compression_level 12"

    msg "Creating home archive from ${VIP_TC} to ${VOP_TC} in ${VDOFIL}..."
    ffmpeg ${FFOPTS} -i "${VDOFIL}" -ss "${VIP_TC}" -to "${VOP_TC}" -vf ${V_FLTR} ${VDOSET} -af ${A_FLTR} ${AUDSET} homearch.mkv

    ;;

  thumb)

    [[ ! "${2}" =~ ^[+-]?[0-9]+([.][0-9]+)?$ ]] && echo "'${2}' is not a number.  ${0} thumb [number]" && exit

    if [ -f ${SCRPNM}.cfg ]; then
      load_config
      check_config
      process_config
      [[ $( awk "BEGIN { print (${2} > 0) }" ) == 1 ]] && TMCODE=$( awk "BEGIN { print ${VIPSEC%.*} + ${2} }" ) || TMCODE=$( awk "BEGIN { print ${VOPSEC%.*} + ${2} }" )
      ffmpeg ${FFOPTS} -i "${VDOFIL}" -ss "${TMCODE}" -vframes 1 "tn$(printf "%07.2f" "${TMCODE}" | sed 's/\.//g').png"
    else
      shopt -s nullglob
      for DRFILE in *.{3gp,asf,avi,divx,evo,f4v,flv,m2ts,mkv,mov,mp4,mpg,ogg,ps,qt,ts,webm,wmv}; do
        if [ -f "${DRFILE}" ]; then
          if [[ $( awk "BEGIN { print (${2} > 0) }" ) == 1 ]]; then
	    TMCODE="${2}"
	  else
	    DRFDUR=$(ffprobe -i "${DRFILE}" 2>&1 | grep Duration | cut -d: -f2- | cut -d, -f1 | sed 's/ //g')
	    TMCODE=$( awk "BEGIN { print $(tc2sec "${DRFDUR}") + ${2} }" )
	  fi
          ffmpeg ${FFOPTS} -i "${DRFILE}" -ss "${TMCODE}" -vframes 1 "${DRFILE%.*}_$(printf "%07.2f" "${TMCODE}" | sed 's/\.//g').png"
        fi
      done
    fi

    ;;

  all)

    shift
    if [ "${1}" == "dryrun" ]; then
      DRYRUN=true
      shift
    else
      DRYRUN=false
    fi

    PRCLST=(${1//+/ })
    shift

    TARGET=()
    TRGSRT=()

    for ALLPRC in "${PRCLST[@]}"; do
      case "${ALLPRC}" in
        join|lossless|portable|preview|vcap|youtube)
          FDFILE="vcproc.cfg"
          ;;
        normalize|remux|set|splitav|trim)
          FDFILE="${1}"
          ;;
        *)
          echo "Can't run ${ALLPRC} on multiple directories"
          exit 1
          ;;
      esac
    done

    while read -r -d '' LOCATN; do
      LOCTRM="${LOCATN%/${FDFILE}}"
      TARGET+=("$(stat -c %Y "${LOCTRM#./}/${FDFILE}"):${LOCTRM#./}")
    done < <(find -name "${FDFILE}" -print0)

    set -f
    IFS=$'\n' TGTSRT=($(sort <<<"${TARGET[*]}"))
    unset IFS
    set +f

    TARGET=()
    for ELMENT in "${TGTSRT[@]}"; do
      TARGET+=("${ELMENT#*:}")
    done

    if ${DRYRUN}; then
      IFS=$'\n'
      msg "DRYRUN: The following directories will be worked on:"
      echo "${TARGET[*]}"
      unset IFS
    else
      CURDIR="$(pwd)"
      for DRCTRY in "${TARGET[@]}"; do
        for ALLPRC in "${PRCLST[@]}"; do
          cd "${DRCTRY}"
          case ${ALLPRC} in
            set) FDFILE="$(ls -U vcproc.cfg 2> /dev/null)" ;;
            *)   FDFILE="$(ls -U ${ALLPRC}.{mkv,mp4,ts} 2> /dev/null)" ;;
          esac
          if [ "${FDFILE}" == "" ]; then
            msg ":: Working on ${DRCTRY}/${ALLPRC}" "${CLBGRN}"
            "${SCRPNM}" "${ALLPRC}" $@
          else
            echo "${DRCTRY}/${FDFILE} exists -- skipping."
          fi
          cd "${CURDIR}"
        done
      done
    fi

    ;;

  *)

    msg "The '${PROCES}' process is unknown."
    exit 1
    ;;

esac

if [[ "|portable|youtube|" == *"|${PROCES}|"* ]]; then
  if [ ! -z ${USETMP+X} ]; then
    msg "Moving ${OUTFIL} to ${PROCES}.mp4"
    mv "${OUTFIL}" ${1}.mp4
    msg 'Cleaning up...'
    rm "${WRKFIL}"
  fi
fi

msg "${PROCES} finished successfully." "$( [ ${PROCES} == all ] && echo "${CLBGRN}" )"
